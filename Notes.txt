Section 1 : Getting Started

- Introduction
? Fundamental Concepts
? Creating concepts
? Browing project history
? Branching & merging
? Collaborating using Github
? Rewriting history

- What is git
? Popular version control system
? Version control system 
Records changes made to code over time in a database
called repository.
History : who has made what changes and when
? Track History, Work Together
? 2 types of VCS
Centralized :
All team members connect to center server to get latest copy
and share changes with others. E.g. : Subersion, Team Foundation Server
Problem is, single point of failure, i.e., central server
Distributed :
Every member have copy of the project and history, so snapshots are saved locally
Can synchronize work directly with others
E.g. : Git, Mercurial
? Git : Free, open source, super fast, scalable, cheap branching/merging
? More than 90% of project uses git.

- Using git
? The command line : fastest, easiest
? Code editors & IDEs
? VSCode : extension - GitLens
? Graphical User Interfaces
GitKraken, Sourcetree
GUI tools have limitations
GUI tools are not always available

- Installing git
? Check git version : git --version

- Configuring git
? Config - Name (user.name), Email (user.email),
Default Editor (core.editor "code --wait"),
Line Ending (core.autocrlf) :
crlf - carriage return line feed
Windows uses - cr+lf, Linux/macos - lf
In windows setting will be - true
In linux/macOs for removing cr on storing,
setting will be - input
? e.g. - git config --global user.name "Mosh Hamedani"
? Level : 
System - All users,
Global - All repo of the current user,  git config --global
Local - The current repo
? Configuration settings are store in text file (.gitconfig),
open it as :
git config --global -e

- Getting Help
? search online : git config
? on termial : get <option> --help, git <option> -h
------------------------------------------------------------------------------

Section 2 : Creating Snapshots

- Initialize a repository
? git init
? ls -a : listing all files including hidden
? .git folder has
foldes : branches, hooks, info, objects, refs
files : config, description, HEAD
? Terminal app : zsh with git plugin

- Git workflow
? Create/Modify files > Add to staging area > Create commit
? Staging area also called as Index
? Staging area used to review work
? Changes can be unstaged.
? Staging area is not empty after commiting changes.
It is similar to commited snapshot.
? Commit has
ID - generated by git
Message, Date/time, Author, Complete snapshot.
? Git compresses content and doesn't store duplicate content.

- Staging files
? Adding files to staging area
git add file1 file2 ... / git add *.txt
For all files : git add . 
? echo hello > file : writes to file
? echo hello >> file : appends to file
? Adding files to staging area copies files to it.

- Committing changes
? git commit -m "message"
? If commit message is long then use
git commit, then default editor will open to write message for commit.
Ideally : first line is short description (<80 chars), then after line break 
type long description. 
lines starting with # will be ignored.

- Committing best practices
? Commit shouldn't be too big or small. (update of a file, feature wise)
? Commit often.
? Each commit should represent logical separate chain set.
? Fixing bug and type should be in different commits
? Create meaningful commit messages
? Wording : Present or Past tense.

- Skipping the staging area
? Not needing review
? git commit -a -m "message" or 
git commit -am "message"
? -a is for all modified files.

- Removing files
? Delete file then > git add > commit it.
? Files in staging area : git ls-files
? git command for removing files
git rm <filenames or patterns>
Removes both from directory and staging area.

- Renaming or moving files
? Rename/remove > git add (for deletion and addition) > commit it
? After staging, git recognizes renaming of files.
? git command for renaming/moving files
git mv currentfilename targetfilename
Renaming/moving is applied to both working directory and staging area 

- Ignoring files
? Create .gitignore file in root of project
? Add files and directories to it as
logs/
main.log
*.log
? It only work when file are not included in repository.
? Untracking files
Remove file from staging area : git rm --cached -r filename
Then commit it
? github.com/github/gitignore, gitignore templates

- Short status
? git status -s
left column : staging area
right column : working directory
? - untracked, M - modified, A - added

- Viewing staged and unstaged changes
? git diff --staged
between staged area and last commit
? git diff
between working directory and staging area
? Output
1. diff --get a/file1.js b/file1.js 
diff utility was called with args. a is old (in commit) b in (staging area)
2. index badfb70...47c3216 100644 <- Meta data
3. --- a/file1.js
+++b/file1.js
legend, changes in old copy by minus and new copy by plus sign
When no old copy exists then we see --- /dev/null
4. @@ -1,3 +1,5 @@
header with info about changed parts of file
It has line no (from to to)
it gives context to chunk.
git divides file in chunks and shows them with header, with
changed lines
5. hello
world
test
+sky
+ocean
part of a chunk. added line shown with plus and deleted with 
minus.


- Visual diff tools
? Diff Tools
KDiff3, P4Merge, WinMerge (Windows Only), VSCode
? Making VSCode default diff tool
Giving name : git config --global diff.tool vscode
Launch VSCode :
git config --global difftool.vscode.cmd "code --wait --diff $LOCAL $REMOTE"
LOCAL : old file placeholder, REMOTE : new file placeholder.
? View / edit configuration file
git config --global -e
Correct command part in the file, as placeholders are lost.
? Using tool
Working dir vs staging area : git difftool
staging area vs last commit : git difftool --staged

- Viewing history
? git log
identifier : 40 char hex string unique identifier
HEAD to master
Author, Date time, description
space to go to next page
? git log --oneline
Short summary
unique identifier with 7 chars
HEAD to master
one line description
? git log --oneline --reverse
first to last order

- Viewing a commit
? show command (shows diff)
Reference using identifier
git show <some identifier chars>
Reference using HEAD pointer
git show HEAD~<steps to go back>
? viewing final version in a commit
git show HEAD~steps:<path to file>
? Viewing all files in commit
git ls-tree HEAD~steps
? Files represented using blobs, and dirs using tree in git database.
? Viewing objects (files / dirs) in git database
git show <some identifier chars>
Objects can be : commits, blobs, trees and tags

- Unstaging files
? Restoring staging area
git restore --staged <filenames.. or patterns or period for all>
? Restore command takes copy from the next environment
for staging : last commit,
for working dir : staging area.

- Discarding local changes
? Restoring working directory
git restore <filenames.. or patterns or period for all>
? File from staging area is copied to working dir.
? It doesn't work for untracked files
? Force clean is required to remove new untracked files
git clean -fd (force and directories)

- Restoring a file to an earlier version
? By default git restores for next environment
If not in staging area then last commit.
? git restore --source=HEAD~steps <filepath>
source is commit where file will be copied from.
New untracked file will be created.

- Creating snapshots with vscode
? Source panel shows similar to output of status command

- Creating snapshots with gitkraken
? gitkraken is only a gui tool.
? Open repository
? It has
List of commits, Author, Message, Date time
? More details click on commit
commit id, message, author, date time,
summary of changes (list/tree view, view all files)
? Getting diff 
click on file in summary of changes
Diff view and file view
In Diff view : split, inline and hunk view
? Changes can be staged / unstaged / viewed / committed.
------------------------------------------------------------------------------

Section 3 : Browsing History

- Introduction
? Search for commits (by author, date, message etc)
? View a commit
? Restore your project to an earlier point
? Compare commits
? View the history of a file
? Find a bad commit that introduced a bug

- Viewing the history
? git log
commit id, author, date time, message
? git log --oneline
? git log --stat
See all changed files
Can be used with oneline
? git log --patch
See actual changes as diff.
Can be used with oneline

- Filtering the history
? Last 3 commits
git log --oneline -3
? Author : git log --oneline --author="author name"
? Date : git log --oneline --after/--before="2020-08-17"
git log --oneline --after/--before="yesterday/one week ago"
? Message : git log --oneline --grep="Search term"
Case sensitivie
? Content : git log --oneline -S"search term"
Added or removed
--patch can be used to view changes.
? Commits range
git log --oneline fb0d187..edb3594
? Commits effecting a file
git log --oneline filename OR
git log --oneline -- filename (when ambiguity occurs)

- Formatting the log output
? git log --pretty=format:"<format string>"
? format string can be as
%Cgreen%an%Creset commited %h on %cd
an authorname
H commit id 
h short commit id
cd commit date
%Cgreen green color
%Creset reset color
? In git-log docs all placeholders can be found

- Creating aliases
? git config --global alias.<command name> "command":
git config --global alias.lg "log --pretty=fomat:'<format string>'"
? Use it as : git lg
? Alias for unstaging changes
git config --global alias.unstage "restore --staged ."

- Viewing a commit
? Referenced by
Id : git show <id>
HEAD pointer : git show HEAD~2
? View final version
git show HEAD~2:sections/creating-snap/file.txt
? View modified files
Name only : git show HEAD~2 --name-only
Also file status : git show HEAD~2 --name-status

- Viewing the changes across commits
? Difference between two commits
git diff HEAD~2 HEAD
? Of only a file
git diff HEAD~2 HEAD filename
? name-status or name-only can also be appended to cmd

- Checking out a commit
? Restores working directory to the commit
? git checkout <commit id/branch name>
? HEAD points to commit we are working on
? Commit created not on a branch will be dead and deleted.
? git log shows old commit from current Head pointer
? Viewing all commits
git log --oneline --all

- Finding bugs using bisect
? Identify good and bad commit
? Using bisect
git bisect start
git bisect bad (marks current commit as bad)
git bisect good <good commit id>
Using log check location of HEAD now.
Test it for presence of bug
Mark it as bad or good as
git bisect good/bad
HEAD position will change again, test it and mark it, then repeat
till bad commit is found
? Reattaching HEAD pointer
git bisect reset

- Finding contributors using shortlog
? git shortlog
Name, commits count, log messages
? options
-n : sort output based on commits count of author
-s : suppress commit messages
-e : show email address
? Filtering options
date range
--before="date" --after="date"

- Viewing the history of a file
? Commits touched a file
git log filename
? Gettings stats
git log --stat filename
? View actual changes
git log --patch filename

- Restoring a deleted file
? git log --oneline -- filename
? Get file from commit previous of commit where file was deleted.
? git checkout <commit id> filename
? File also copied to staging area

- Blaming : Finding the author of line using blame
? git blame filename
? With email : git blame -e filename
? Filter by lines
git blame -e -L 1,3 filename

- Tagging
? Bookmarking commits (version etc)
? Adding label
Tagging last commit : git tag v1.0
Tagging earlier commit : git tag v1.0 <commit id>
? Reference using tag
git checkout v1.0
? See all tags : git tag
? Lightweight tag
? Another type of tag :
Annotated tag, 
complete object having tagger name,
email, message
? Creating annotated tag
git tag -a v1.1 -m "message"
? See all tags with message : git tag -n
? Viewing annotated tag
git show <annotated tag name>
? Deleting tag : git tag -d <tag name>

- Browing history using VSCode
? Install GitLens extension
? Limitation : No second filter, lack of bisect command

- Browsing history using gitkraken
* Open repository
* Search commits : id, author, message
* Select commits to view details
id, author, time, summary of modified files
* Select history in file view to view history
* Ctrl+P : command pallette.
------------------------------------------------------------------------------

Section 4 : Branching

- Introduction
* Use branches
* Compare branches
* Merge branches
* Resolve conflicts
* Undo a faulty merge
* Essential tools (stashing, cherry picking)

- What are branches
* For working with new work items without messing with main line
of work.
* To keep main line stable and ready for release.
* Anyone joining can start on stable codebase.
* Subversion vcs copies entire project on creation of branch,
so consuming high space
* Git branches are pointer to a commit.
* On creation of branch git creates a new pointer which can be moved
around.
* Using HEAD pointer knows currently selected branch. HEAD pointer is
a file containing name of branch/commit

- Working with branches
* When we get bug report
* To fix it we should create new branch
git branch bugfix
* See list of branches : git branch
* Switching branch
git checkout bugfix (old way)
git switch bugfix
* Renaming branch
git branch -m bugfix bugfix/signup-form
* Stage and commit it
* Deleting a branch
git branch -d bugfix/signup-form (need to be fully merged)
Forcing delete : git branch -D bugfix/signup-form
* Create and switch branch in one command
git switch -C bugfix

- Comparing branches
* What commits are comming in master
Showing commits that are in bugfix and not in master
git log master..bugfix/signup-form
* See actual changes
git diff master..bugfix/signup-form
git diff bugfix/signup-form (comparing bugfix with current branch)
* See affected file names
git diff --name-status bugfix/signup-form

- Stashing
* For storing uncommitted changes temporarily, when switching branch.
* Not part of history
* Use stashing as :
git stash push -m "message"
* By default new untracked file are not included in stash.
* Stashing including untracked files
git stash push -am "message" (a for all files)
* View stash : git stash list 
list is as stash@{0}, stash@{1} etc
* Looking changes inside stash
git stash show stash@{1}
or git stash show 1
* Applying stash : git stash apply 1
* Removing stash : git stash drop 1
* Removing all : git stash clear

- Merges
* Fast-forward (if branches have not diverged)
When linear path exists
Brings pointer of source branch forward
* 3-way (if branches have diverged)
3 commits are taken into consideration.
common ancestor commit of branches, and current commits of branches.
New commit is created called as merge commit.

- Fast forward merge
* Using --graph option
git log --oneline --all --graph
* Merging master with bugfix/signup-form
git merge bugfix/signup-form
* Using No fast forward merge
Creates a new commit for merge operation
git merge --no-ff bugfix/login-form
Editor opens for message for merge commit.
Pollutes the history, true reflection of history, 
allows reverting a feature (create a new commit undoing last commit).
* Disabling fast forward merges
Current repo : git config ff no
Globally : git config --global ff no

- 3 way merge
* git merge <branch>
* 3 commits are taken into consideration.
* common ancestor commit of branches, and current commits of branches.
* New commit is created called as merge commit.

- Viewing merged and unmerged branches
* After merging a branch, it should be deleted.
* Viewing merged branches
git branch --merged
Delete it as : git branch -d <branch>
* Viewing unmerged branches
git branch --no-merged

- Merge conflicts
* Conflicts
Same code changed in different branches
File changed in one and deleted in other.
Same file added with different contents.
* Git stops merge process when conflict appears
* git status shows conflicts in Unmerged paths
* Open conflicted file
It has markers representing changes in current and other branch
<<<HEAD
changes
====
changes
>>>>> branch name
* Options for conflicted changes
Accept current, accept incoming, accept both or manually as
Manually : reordering etc.
Avoid adding new code in merge commit
* Merge commit with new code is referred as evil commit.
Changes introduced doesn't exist in source branches.
* Add file to staging area > then commit and accept default message.

- Visual merge tools
* Merge tools
Kdiff, P4Merge, WinMerge
* Using p4merge
Configure default tool : 
git config --global merge.tool p4merge
Where to find :
git config --global mergetool.p4merge.path "<path to p4merge>"
* Resolving conflicts during merge
git mergetool

- Aborting a merge
* git merge --abort

- Undoing a faulty merge
* 2 ways
Remove commit, Revert changes
* Removing commit
Rewriting history,
only when changes are local.
Shouldn't rewrite if changes are already shared.
Use reset command to move master pointer to it's last commit.
Faulty merge commit will become garbage and will be removed
by git.
git reset --hard HEAD~1
Resetting options :
soft - only HEAD pointer changed to last snapshot
mixed (default) - staging area also changed
hard - working directory also changed
* Reverting changes
Creating commit which revertes changes.
First parent of merge is parent of same branch
Reverting to last master branch commit :
git revert -m 1 HEAD (1 means first parent)

- Squash merging
* When commits are not of good quality or not want
history of a branch.
* Create a commit on master which takes all changes of a branch
and apply them as a separate normal commit on master branch.
* Not a merge commit, doesn't have 2 parents, doesn't have
reference to another branch.
* Use with small short lived branches with bad history (bugfixes, 
features implemented in few hours or in a day).
* Merging
git merge --squash <branch name>
All changes are only staged
Create commit with meaningful message
git commit -m "Fix the bug etc."
* Branch is need to be force deleted after squash merging,
as this branch will not appear as merged with master, creating
confusion.
* Conflict resolution is same as others.

- Rebasing
* Changing base of a branch to current master, so fast forward
merge is possible
* Rebasing rewrites history
* Use for only local commits.
* Commits in git are immutable
* Git will create new commits parallel to the commits of the branch 
during rebasing, so that linear flow appears. Old commits of the branch
will be deleted by git.
* Rebasing
From target branch do : git rebase master
From master branch do fast forward merge.
* Resolving conflicts
Using mergetool resolve conflict.
apply next comit : git rebase --continue
skipping commit : git rebase --skip
aborting rebasing : git rebase --abort
* Preventing mergetool to automatically create backupfiles
git config --global mergetool.keepBackup false

- Cherry picking
* Applying a commit from a different branch to current branch.
* Conflict resolution is required.
* git cherry-pick <commit id>
* resolve conflict if there are any
* Make commit with original (or changed) message: git commit

- Picking a file from another branch
* git restore --source=<branch name> -- filenames
* Latest version of file from branch will copied.
* Stage and commit the file.

- Branching in VSCode
* Graph of branches
install git graph
------------------------------------------------------
Section 5 : Collaboration

- Introduction
? Collaboration workflows
? Pushing, fetching and pulling
? Pull requests, issues and milestones
? Contributing to open-source projects

- Workflows
? Centralized VCS
? Distributed VCS
? Distributed VCS with centralized workflow
Don't have single point of failure
Central repo can put on private server or cloud
? Private repo : John pushes commit to central repo, amy pulls changes
if confilcts arises then conflict are resolved and changes are
pushed to central repo. Everyone has push right.
? Public repo : Integration-manager
have one or more maintainer and many contributors.
Contributor forks the repository (getting copy in cloud), clones it, 
makes changes, pushes it to copy in cloud, then sents pull request
to maintainer. Then maintainer views forked repo and pulls changes to
merge changes with main repo and pushes it.

- Adding collaborators in github
? In settings
manage access > Invite collaborator

- Cloning a repository
? Cloning with custom folder name
git clone <link> <folder name>
origin/master is a remote tracking branch

- Fetching
? Downloading new commit from remote
git fetch
origin/master will be moved forward.
? Merging of master with origin/master is required
git merge origin/master
? Viewing divergence of local and remote branches
git branch -vv

- Pulling
? Combines fetch + merge
? git pull
? Doing rebasing instead of 3 way merge
git pull --rebase
rebases master branch on origin/master

- Pushing
? git push
? Push is rejected when remote branch history is changed.
Then new history need to be pulled and merged before pushing.
? Don't use force (-f) option.

- Storing credentials
? Storing in memory
git config --global credential.helper cache
stored for only 15 mins
? Storing on disk
Using credential helper
Mac: Keychain, Windows: Windows credential store
? Check for keychain helper
git credential-osxkeychain
git config --global credential.helper osxkeychain

- Sharing tags
? By default push command doesn't transfer tags to remote
? Pushing tag
git push origin <tag name>
? Deleting tag from remote
git push origin --delete <tag name>

- Releases
? Github feature
? High level feature build on top of tags
? In home page of repository
tags > releases > create a new release
Create or use existing tag, select branch, 
write title description, add binaries, then publish.

- Sharing branches
? Branches need to be explicitly pushed like tags
? Viewing all remote tracking branches
git branch -r
? Pushing new branch
git push -u origin <new branch> (u means set upstream)
? Removing branch
git push -d origin <branch> (d for delete)

- Collaboration Workflow
? Creating a feature
one person creates a feature branch or create feature branch
on github and pulled by both devs. > git fetch to get branch
> Create new local branch and map it to remote branch
git switch  -C feature/change-password origin/feature/change-password
> 2nd dev clones repo > it creates local branch in same way
> it creates a new commit and pushes it.
? When feature is complete, the close the branch
Pull all latest changes > merge feature with master > 
push to send final change > Remove feature branch
from origin > Remove feature local branch > 2nd dev
also pulls latest changes > Remove feature local branch
> Update remote branches (git remote prune origin)

- Pull requests
? Open discussion with team before merging
? After completing a branch, a pull request is created, give 
title and description > Add reviewer from collaborators
? Reviewer views pull request > views changes > add
comments to lines or code > Finish review by giving a 
general description > mark it as comment / approve / request
changes > submit review.
? Creater makes changes according to request and pushes.
> And request for new review. > then reviewer can approve.
> After creater or reviewer can merge branch > the branch
can be deleted after. > prune remote and delete local branch.

- Issues
? Feature of Github, associated with pull requests
? Track bugfixes, new features, enhancements, ideas etc.
? Create issue with title and description and attach files.
? Can be assigned to one or more people. Or one can
assign himself.
? Labels can be added to issue.
? Can be linked to pull requests.
? Issue is automatically closed on closing of pull request.
? Can be assigned to milestone.

- Github labels
? In issues > Labels
? New label can be created - name, description, color.
? Issues for each labels can be viewed.

- Github milestones
? To track progress of various issues.
? Bunch of issues can be added to a milestone.
? Issues can be assigned to a milestone.

- Contributing to open source projects
? Pull request in a forked repo is compared with original 
base repository.

- Keeping a forked repository up to date
? Add another reference to base repository
git remote add base <base repo url>
? Pull/fetch from base remote repo to local
git fetch base (origin is default for fetch)
git merge base/master
? Push to forked repository
? Renaming remote repository
git remote rename <old name> <new name>
? Remove remote reference
git remote rm <repo name>
? Good practice : merge master with local feature branch regularly so that working on feature branch will have latest
code and less conflicts in future with master. Bringing change of master into feature branch.
--------------------------------------------------------------

Section 6 : Rewriting History

- Introduction
? Dangerous feature
Drop/modify commits, combine/split
? Why and when to rewrite history
? Undo or revert commits
? Use interactive rebasing
? Recover lost commits

- Why rewrite history
? Why need history : What was changed, why and when.
? Bad history
Poor commit messages, Large commits, Small commits
? Clean history : how its evolved from day 1.
? Tools :
Squash small, related commits
Split large commits
Reword commit message
Drop unwanted commits
Modify commits (content)

- The Golden Rule of rewriting history
? Don't rewrite public history
? Rewriting private history is fine.

- Undoing commits
? New commit undoing previous commit
git revert HEAD
? Removing commit from history
git reset --hard HEAD~1

- Reverting commits
? git revert HEAD
? Some previous commit
git revert HEAD_2
? Range of previous commits
git revert HEAD~3..HEAD (doesn't include HEAD~3)
Multiple revert commits are created
? Reverting range in one commit
Adding reverting changes to staging area only
git revert --no-commit HEAD~3..HEAD
Aborting revert : git revert --abort
Continuing : git revert --continue
Write a message which describes multiple reverts.

- Recovering last commits
? View history of references movement
HEAD pointer : git reflog
branch : git reflog show <branch>
? Recovering by resetting
git reset <reflog entry> OR
git reset <commit id>

- Ammending the last commit
? Stage required changes
? git commit --ammend  [optional -m "new message"]
? Git at back creates new commit and replaces last one.
? Removing an added file from last commit
Reset head with mixed option :
git reset --mixed HEAD~1
Delete target untracked file : git clean - fd
Stage changes : git add .
Create new commit : git commit -m "message"

- Ammending an earlier commit
? Using interactive rebasing
? The target commit and earlier from that will be replayed/recreated
? git rebase -i <commit id>
? Editor will open with script having rebase operation
? Edit 'pick' to 'edit' for commit we want to ammend. 
Close the editor.
? Make changes and stage them
? git commit --ammend
? git rebase --continue
? Rebase can be aborted : git rebase --abort
? Rebasing rewrites history
? Only for the unshared commits.

- Dropping a commit
? Viewing commit 
git show <commit id>
? Start interactive rebase with parent commit of target
commit.
git rebase -i <commit id>^ (^ means parent)
? Editor will open with rebase operation script
? Edit 'pick' to 'drop' of target commit, or delete line.
Close the editor.
? Conflict will arise. Resolve the conflict
? Continue : git rebase --continue

- Rewording commit messages
? Using interactive rebasing from parent
git rebase -i <commit id>^
? In Editor change pick to reword for the commits. Close
the editor.
? Git will opend editor for the commits, and then change messages.

- Reordering commits
? Using interactive rebasing from commit after which we
want the target commit.
git rebase -i <before location commit id>
? Editor will open, move pick command of target commit up
in the editor. Close the editor

- Squashing commits
? Using interactive rebasing from parent
git rebase -i <commit id>^
? Editor will open, excluding 1st target commit, change pick to 
squash for next commits to be squashed. Close the editor.
? Give commit message.
? If commits are not next to each other, then they can be
reordered.
? Instead of 'squash', 'fixup' can be used, it makes use of first
commit's message and doesn't ask for new commit message.

- Splitting a commit
? Creating multiple commits instead of the target commit.
? Using interactive rebasing from parent
git rebase  -i <commit id>^
? In Editor change pick to edit for target commit
? Split it as
move to previous commit : git reset HEAD^
Stage area also has changed to previous commit
Stage first change and commit it.
Then stage second change and commit it.
Continue rebasing : git rebase --continue

- Rewriting history using gitkraken
? Cannot split, ammend or edit commit


